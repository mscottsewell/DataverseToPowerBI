'use client';
import * as React from 'react';
import { useEventCallback, slot, isResolvedShorthand } from '@fluentui/react-utilities';
import { useARIAButtonProps } from '@fluentui/react-aria';
import { useAccordionContext_unstable } from '../../contexts/accordion';
import { ChevronRightRegular } from '@fluentui/react-icons';
import { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import { useAccordionItemContext_unstable } from '../../contexts/accordionItem';
import { motionTokens } from '@fluentui/react-motion';
/**
 * Returns the props and state required to render the component
 *
 * @param props - AccordionHeader properties
 * @param ref - reference to root HTMLElement of AccordionHeader
 */ export const useAccordionHeader_unstable = (props, ref)=>{
    const state = useAccordionHeaderBase_unstable(props, ref);
    const { dir } = useFluent();
    // Calculate how to rotate the expand icon [>] (ChevronRightRegular)
    let expandIconRotation;
    if (state.expandIconPosition === 'end') {
        // If expand icon is at the end, the chevron points up [^] when open, and down [v] when closed
        expandIconRotation = state.open ? -90 : 90;
    } else {
        // Otherwise, the chevron points down [v] when open, and right [>] (or left [<] in RTL) when closed
        expandIconRotation = state.open ? 90 : dir !== 'rtl' ? 0 : 180;
    }
    if (state.expandIcon) {
        var _state_expandIcon;
        var _children;
        (_children = (_state_expandIcon = state.expandIcon).children) !== null && _children !== void 0 ? _children : _state_expandIcon.children = /*#__PURE__*/ React.createElement(ChevronRightRegular, {
            style: {
                transform: `rotate(${expandIconRotation}deg)`,
                transition: `transform ${motionTokens.durationNormal}ms ease-out`
            }
        });
    }
    return state;
};
/**
 * Base state hook for AccordionHeader, without design related features.
 *
 * @param props - AccordionHeader properties
 * @param ref - reference to root HTMLElement of AccordionHeader
 */ export const useAccordionHeaderBase_unstable = (props, ref)=>{
    const { icon, button, expandIcon, inline = false, size = 'medium', expandIconPosition = 'start', ...rest } = props;
    const { value, disabled, open } = useAccordionItemContext_unstable();
    const requestToggle = useAccordionContext_unstable((ctx)=>ctx.requestToggle);
    /**
   * force disabled state on button if accordion isn't collapsible
   * and this is the only item opened
   */ const disabledFocusable = useAccordionContext_unstable((ctx)=>!ctx.collapsible && ctx.openItems.length === 1 && open);
    const buttonSlot = slot.always(button, {
        elementType: 'button',
        defaultProps: {
            disabled,
            disabledFocusable,
            'aria-expanded': open,
            type: 'button'
        }
    });
    buttonSlot.onClick = useEventCallback((event)=>{
        if (isResolvedShorthand(button)) {
            var _button_onClick;
            (_button_onClick = button.onClick) === null || _button_onClick === void 0 ? void 0 : _button_onClick.call(button, event);
        }
        if (!event.defaultPrevented) {
            requestToggle({
                value,
                event
            });
        }
    });
    return {
        disabled,
        open,
        size,
        inline,
        expandIconPosition,
        components: {
            root: 'div',
            button: 'button',
            expandIcon: 'span',
            icon: 'div'
        },
        root: slot.always({
            ref: ref,
            ...rest
        }, {
            elementType: 'div'
        }),
        icon: slot.optional(icon, {
            elementType: 'div'
        }),
        expandIcon: slot.optional(expandIcon, {
            renderByDefault: true,
            defaultProps: {
                'aria-hidden': true
            },
            elementType: 'span'
        }),
        button: useARIAButtonProps(buttonSlot.as, buttonSlot)
    };
};
