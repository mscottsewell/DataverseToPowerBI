{"version":3,"sources":["../src/overflowManager.ts"],"sourcesContent":["import { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { observeResize } from './createResizeObserver';\nimport { debounce } from './debounce';\nimport { createPriorityQueue, PriorityQueue } from './priorityQueue';\nimport type {\n  OverflowGroupState,\n  OverflowItemEntry,\n  OverflowManager,\n  ObserveOptions,\n  OverflowDividerEntry,\n} from './types';\n\n/**\n * @internal\n * @returns overflow manager instance\n */\nexport function createOverflowManager(): OverflowManager {\n  // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n  // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n  const sizeCache = new Map<HTMLElement, number>();\n  let container: HTMLElement | undefined;\n  let overflowMenu: HTMLElement | undefined;\n  // Set as true when resize observer is observing\n  let observing = false;\n  // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n  // Initially true to force dispatch on first mount\n  let forceDispatch = true;\n  const options: Required<ObserveOptions> = {\n    padding: 10,\n    overflowAxis: 'horizontal',\n    overflowDirection: 'end',\n    minimumVisible: 0,\n    onUpdateItemVisibility: () => undefined,\n    onUpdateOverflow: () => undefined,\n    hasHiddenItems: false,\n  };\n\n  const overflowItems: Record<string, OverflowItemEntry> = {};\n  const overflowDividers: Record<string, OverflowDividerEntry> = {};\n  let disposeResizeObserver: () => void = () => null;\n\n  const getNextItem = (queueToDequeue: PriorityQueue<string>, queueToEnqueue: PriorityQueue<string>) => {\n    const nextItem = queueToDequeue.dequeue();\n    queueToEnqueue.enqueue(nextItem);\n    return overflowItems[nextItem];\n  };\n\n  const groupManager = createGroupManager();\n\n  function compareItems(lt: string | null, rt: string | null): number {\n    if (!lt || !rt) {\n      return 0;\n    }\n\n    const lte = overflowItems[lt];\n    const rte = overflowItems[rt];\n\n    // TODO this should not happen but there have been reports of one of these items being undefined\n    // Try to find a consistent repro for this\n    if (!lte || !rte) {\n      return lte ? 1 : -1;\n    }\n\n    // Pinned items have \"infinite\" priority - they should never be hidden\n    if (lte.pinned !== rte.pinned) {\n      return lte.pinned ? 1 : -1;\n    }\n\n    if (lte.priority !== rte.priority) {\n      return lte.priority > rte.priority ? 1 : -1;\n    }\n\n    // Node.DOCUMENT_POSITION_FOLLOWING = 4, Node.DOCUMENT_POSITION_PRECEDING = 2\n    const positionStatusBit = options.overflowDirection === 'end' ? 4 : 2;\n\n    // eslint-disable-next-line no-bitwise\n    return lte.element.compareDocumentPosition(rte.element) & positionStatusBit ? 1 : -1;\n  }\n\n  function getElementAxisSize(\n    horizontal: 'clientWidth' | 'offsetWidth',\n    vertical: 'clientHeight' | 'offsetHeight',\n    el: HTMLElement,\n  ): number {\n    if (!sizeCache.has(el)) {\n      sizeCache.set(el, options.overflowAxis === 'horizontal' ? el[horizontal] : el[vertical]);\n    }\n\n    return sizeCache.get(el)!;\n  }\n\n  const getOffsetSize = getElementAxisSize.bind(null, 'offsetWidth', 'offsetHeight');\n  const getClientSize = getElementAxisSize.bind(null, 'clientWidth', 'clientHeight');\n\n  const invisibleItemQueue = createPriorityQueue<string>((a, b) => -1 * compareItems(a, b));\n\n  const visibleItemQueue = createPriorityQueue<string>(compareItems);\n\n  function occupiedSize(): number {\n    const totalItemSize = visibleItemQueue\n      .all()\n      .map(id => overflowItems[id].element)\n      .map(getOffsetSize)\n      .reduce((prev, current) => prev + current, 0);\n\n    const totalDividerSize = Object.entries(groupManager.groupVisibility()).reduce(\n      (acc, [id, state]) =>\n        acc + (state !== 'hidden' && overflowDividers[id] ? getOffsetSize(overflowDividers[id].element) : 0),\n      0,\n    );\n\n    const overflowMenuSize =\n      (invisibleItemQueue.size() > 0 || options.hasHiddenItems) && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n\n    return totalItemSize + totalDividerSize + overflowMenuSize;\n  }\n\n  const showItem = () => {\n    const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n    options.onUpdateItemVisibility({ item, visible: true });\n\n    if (item.groupId) {\n      groupManager.showItem(item.id, item.groupId);\n\n      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n        overflowDividers[item.groupId]?.element.removeAttribute(DATA_OVERFLOWING);\n      }\n    }\n  };\n\n  const hideItem = () => {\n    const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n    options.onUpdateItemVisibility({ item, visible: false });\n\n    if (item.groupId) {\n      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n        overflowDividers[item.groupId]?.element.setAttribute(DATA_OVERFLOWING, '');\n      }\n\n      groupManager.hideItem(item.id, item.groupId);\n    }\n  };\n\n  const dispatchOverflowUpdate = () => {\n    const visibleItemIds = visibleItemQueue.all();\n    const invisibleItemIds = invisibleItemQueue.all();\n\n    const visibleItems = visibleItemIds.map(itemId => overflowItems[itemId]);\n    const invisibleItems = invisibleItemIds.map(itemId => overflowItems[itemId]);\n\n    options.onUpdateOverflow({ visibleItems, invisibleItems, groupVisibility: groupManager.groupVisibility() });\n  };\n\n  const processOverflowItems = (): boolean => {\n    if (!container) {\n      return false;\n    }\n    sizeCache.clear();\n\n    const availableSize = getClientSize(container) - options.padding;\n\n    // Snapshot of the visible/invisible state to compare for updates\n    const visibleTop = visibleItemQueue.peek();\n    const invisibleTop = invisibleItemQueue.peek();\n\n    while (compareItems(invisibleItemQueue.peek(), visibleItemQueue.peek()) > 0) {\n      hideItem(); // hide elements whose priority become smaller than the highest priority of the hidden one\n    }\n\n    // Run the show/hide step twice - the first step might not be correct if\n    // it was triggered by a new item being added - new items are always visible by default.\n    for (let i = 0; i < 2; i++) {\n      // Add items until available width is filled - can result in overflow\n      while (\n        (occupiedSize() < availableSize && invisibleItemQueue.size() > 0) ||\n        invisibleItemQueue.size() === 1 // attempt to show the last invisible item hoping it's size does not exceed overflow menu size\n      ) {\n        showItem();\n      }\n\n      // Remove items until there's no more overflow\n      while (occupiedSize() > availableSize && visibleItemQueue.size() > options.minimumVisible) {\n        const nextItemId = visibleItemQueue.peek();\n\n        // Never hide pinned items - they should always remain visible\n        if (nextItemId && overflowItems[nextItemId]?.pinned) {\n          break;\n        }\n\n        hideItem();\n      }\n    }\n\n    // only update when the state of visible/invisible items has changed\n    return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n  };\n\n  const forceUpdate: OverflowManager['forceUpdate'] = () => {\n    if (processOverflowItems() || forceDispatch) {\n      forceDispatch = false;\n      dispatchOverflowUpdate();\n    }\n  };\n\n  const update: OverflowManager['update'] = debounce(forceUpdate);\n\n  const observe: OverflowManager['observe'] = (observedContainer, userOptions) => {\n    Object.assign(options, userOptions);\n    observing = true;\n    Object.values(overflowItems).forEach(item => visibleItemQueue.enqueue(item.id));\n\n    container = observedContainer;\n    disposeResizeObserver = observeResize(container, entries => {\n      if (!entries[0] || !container) {\n        return;\n      }\n\n      update();\n    });\n  };\n\n  const addItem: OverflowManager['addItem'] = item => {\n    if (overflowItems[item.id]) {\n      return;\n    }\n\n    overflowItems[item.id] = item;\n\n    // some options can affect priority which are only set on `observe`\n    if (observing) {\n      // Updates to elements might not change the queue tops\n      // i.e. new element is enqueued but the top of the queue stays the same\n      // force a dispatch on the next batched update\n      forceDispatch = true;\n      visibleItemQueue.enqueue(item.id);\n    }\n\n    if (item.groupId) {\n      groupManager.addItem(item.id, item.groupId);\n      item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n    }\n\n    update();\n  };\n\n  const addOverflowMenu: OverflowManager['addOverflowMenu'] = el => {\n    overflowMenu = el;\n  };\n\n  const addDivider: OverflowManager['addDivider'] = divider => {\n    if (!divider.groupId || overflowDividers[divider.groupId]) {\n      return;\n    }\n\n    divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n    overflowDividers[divider.groupId] = divider;\n  };\n\n  const removeOverflowMenu: OverflowManager['removeOverflowMenu'] = () => {\n    overflowMenu = undefined;\n  };\n\n  const removeDivider: OverflowManager['removeDivider'] = groupId => {\n    if (!overflowDividers[groupId]) {\n      return;\n    }\n    const divider = overflowDividers[groupId];\n    if (divider.groupId) {\n      delete overflowDividers[groupId];\n      divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n    }\n  };\n\n  const removeItem: OverflowManager['removeItem'] = itemId => {\n    if (!overflowItems[itemId]) {\n      return;\n    }\n\n    if (observing) {\n      // We might be removing an item in an overflow which would not affect the tops,\n      // but we need to update anyway to update the overflow menu state\n      forceDispatch = true;\n    }\n\n    const item = overflowItems[itemId];\n    visibleItemQueue.remove(itemId);\n    invisibleItemQueue.remove(itemId);\n\n    if (item.groupId) {\n      groupManager.removeItem(item.id, item.groupId);\n      item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n    }\n\n    sizeCache.delete(item.element);\n    delete overflowItems[itemId];\n    update();\n  };\n\n  const disconnect: OverflowManager['disconnect'] = () => {\n    disposeResizeObserver();\n\n    // reset flags\n    container = undefined;\n    observing = false;\n    forceDispatch = true;\n\n    // clear all entries\n    Object.keys(overflowItems).forEach(itemId => removeItem(itemId));\n    Object.keys(overflowDividers).forEach(dividerId => removeDivider(dividerId));\n    removeOverflowMenu();\n    sizeCache.clear();\n  };\n\n  return {\n    addItem,\n    disconnect,\n    forceUpdate,\n    observe,\n    removeItem,\n    update,\n    addOverflowMenu,\n    removeOverflowMenu,\n    addDivider,\n    removeDivider,\n  };\n}\n\nconst createGroupManager = () => {\n  const groupVisibility: Record<string, OverflowGroupState> = {};\n  const groups: Record<string, { visibleItemIds: Set<string>; invisibleItemIds: Set<string> }> = {};\n  function updateGroupVisibility(groupId: string) {\n    const group = groups[groupId];\n    if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n      groupVisibility[groupId] = 'overflow';\n    } else if (group.visibleItemIds.size === 0) {\n      groupVisibility[groupId] = 'hidden';\n    } else {\n      groupVisibility[groupId] = 'visible';\n    }\n  }\n  function isGroupVisible(groupId: string) {\n    return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n  }\n  return {\n    groupVisibility: () => groupVisibility,\n    isSingleItemVisible(itemId: string, groupId: string) {\n      return (\n        isGroupVisible(groupId) &&\n        groups[groupId].visibleItemIds.has(itemId) &&\n        groups[groupId].visibleItemIds.size === 1\n      );\n    },\n    addItem(itemId: string, groupId: string) {\n      groups[groupId] ??= {\n        visibleItemIds: new Set<string>(),\n        invisibleItemIds: new Set<string>(),\n      };\n\n      groups[groupId].visibleItemIds.add(itemId);\n      updateGroupVisibility(groupId);\n    },\n    removeItem(itemId: string, groupId: string) {\n      groups[groupId].invisibleItemIds.delete(itemId);\n      groups[groupId].visibleItemIds.delete(itemId);\n      updateGroupVisibility(groupId);\n    },\n    showItem(itemId: string, groupId: string) {\n      groups[groupId].invisibleItemIds.delete(itemId);\n      groups[groupId].visibleItemIds.add(itemId);\n      updateGroupVisibility(groupId);\n    },\n    hideItem(itemId: string, groupId: string) {\n      groups[groupId].invisibleItemIds.add(itemId);\n      groups[groupId].visibleItemIds.delete(itemId);\n      updateGroupVisibility(groupId);\n    },\n  };\n};\n"],"names":["createOverflowManager","sizeCache","Map","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","hasHiddenItems","overflowItems","overflowDividers","disposeResizeObserver","getNextItem","queueToDequeue","queueToEnqueue","nextItem","dequeue","enqueue","groupManager","createGroupManager","compareItems","lt","rt","lte","rte","pinned","priority","positionStatusBit","element","compareDocumentPosition","getElementAxisSize","horizontal","vertical","el","has","set","get","getOffsetSize","bind","getClientSize","invisibleItemQueue","createPriorityQueue","a","b","visibleItemQueue","occupiedSize","totalItemSize","all","map","id","reduce","prev","current","totalDividerSize","Object","entries","groupVisibility","acc","state","overflowMenuSize","size","showItem","item","visible","groupId","isSingleItemVisible","removeAttribute","DATA_OVERFLOWING","hideItem","setAttribute","dispatchOverflowUpdate","visibleItemIds","invisibleItemIds","visibleItems","itemId","invisibleItems","processOverflowItems","clear","availableSize","visibleTop","peek","invisibleTop","i","nextItemId","forceUpdate","update","debounce","observe","observedContainer","userOptions","assign","values","forEach","observeResize","addItem","DATA_OVERFLOW_GROUP","addOverflowMenu","addDivider","divider","removeOverflowMenu","removeDivider","removeItem","remove","delete","disconnect","keys","dividerId","groups","updateGroupVisibility","group","isGroupVisible","Set","add"],"mappings":"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"}